/**
 * @fileoverview CSS Selector Generation Engine
 * 
 * This module implements CSS selector generation strategies for DOM elements,
 * including uniqueness validation, stability scoring, and confidence assessment.
 * 
 * The generator follows a priority-based approach:
 * 1. ID-based selectors (highest reliability)
 * 2. Attribute-based selectors (form elements)
 * 3. Class-based selectors (with uniqueness validation)
 * 4. Hierarchy-based selectors (parent-child relationships)
 * 5. Tag-based selectors (fallback)
 * 
 * Requirements covered:
 * - 2.1: CSS locator generation strategy
 * - 3.2: Confidence scoring for locator reliability
 * - 3.4: Uniqueness validation and stability assessment
 * 
 * @author LocateFlow Development Team
 * @version 1.0.0
 */

import { LocatorStrategy, ConfidenceScore, ConfidenceFactor } from './data-models';

/**
 * CSS Selector Generation Engine
 * 
 * Generates CSS selectors for DOM elements using various strategies:
 * - ID-based selectors (highest priority)
 * - Class-based selectors
 * - Attribute-based selectors
 * - Hierarchy-based selectors
 * - Tag-based selectors (fallback)
 */
export class CSSelectorGenerator {
  /**
     * Generates a CSS selector for the given element
     * 
     * @param element - The DOM element to generate a selector for
     * @param document - The document context for validation
     * @returns LocatorStrategy with CSS selector and confidence information
     */
  generateCSSSelector(element: HTMLElement, document: Document): LocatorStrategy {
    if (!element) {
      throw new Error('Element cannot be null or undefined');
    }

    if (!document) {
      throw new Error('Document cannot be null or undefined');
    }

    // Try different selector strategies in order of preference
    let selector = this.tryIdSelector(element);

    if (!selector) {
      selector = this.tryAttributeSelector(element);
    }

    if (!selector) {
      selector = this.tryClassSelector(element);
      // If class selector is not unique, try hierarchy
      if (selector && !this.validateUniqueness(selector, element, document)) {
        selector = this.tryHierarchySelector(element);
      }
    }

    if (!selector) {
      selector = this.tryHierarchySelector(element);
    }

    if (!selector) {
      selector = this.tryTagSelector(element);
    }

    // Validate uniqueness
    const isUnique = this.validateUniqueness(selector, element, document);

    // Calculate stability score
    const stabilityScore = this.calculateStabilityScore(selector);
    const isStable = stabilityScore > 60;

    // Generate confidence score
    const confidence = this.generateConfidenceScore(selector, isUnique, stabilityScore);

    // Generate explanation
    const explanation = this.generateExplanation(selector, isUnique, isStable);

    return {
      type: 'css',
      selector,
      confidence,
      explanation,
      isUnique,
      isStable
    };
  }

  /**
     * Validates if a selector uniquely identifies the target element
     * 
     * @param selector - CSS selector to validate
     * @param targetElement - The element that should be uniquely selected
     * @param document - Document context for querying
     * @returns true if selector is unique, false otherwise
     */
  validateUniqueness(selector: string, targetElement: HTMLElement, document: Document): boolean {
    try {
      const elements = document.querySelectorAll(selector);
      return elements.length === 1 && elements[0] === targetElement;
    } catch (error) {
      return false;
    }
  }

  /**
     * Calculates stability score for a CSS selector
     * 
     * @param selector - CSS selector to evaluate
     * @returns Stability score from 0-100
     */
  calculateStabilityScore(selector: string): number {
    let score = 50; // Base score

    // ID selectors are most stable
    if (selector.includes('#')) {
      score = 95;
    }
    // Semantic class names are fairly stable
    else if (selector.includes('.') && !this.hasAutoGeneratedClasses(selector)) {
      score = 75;
    }
    // Attribute selectors are moderately stable
    else if (selector.includes('[')) {
      score = 70;
    }
    // Auto-generated classes are unstable
    else if (this.hasAutoGeneratedClasses(selector)) {
      score = 25;
    }
    // Position-based selectors are very unstable
    else if (selector.includes(':nth-child')) {
      score = 15;
    }
    // Tag-only selectors are unstable
    else if (!selector.includes('.') && !selector.includes('#') && !selector.includes('[')) {
      score = 30;
    }

    return Math.max(0, Math.min(100, score));
  }

  /**
     * Generates confidence score with detailed factors and warnings
     * 
     * @param selector - CSS selector to evaluate
     * @param isUnique - Whether selector uniquely identifies element
     * @param stabilityScore - Stability score of the selector
     * @returns ConfidenceScore with breakdown
     */
  generateConfidenceScore(selector: string, isUnique: boolean, stabilityScore: number): ConfidenceScore {
    const factors: ConfidenceFactor[] = [];
    const warnings: string[] = [];
    let score = 0;

    // Uniqueness factor (40% weight)
    if (isUnique) {
      factors.push({
        factor: 'Uniqueness',
        impact: 'positive',
        weight: 0.4,
        description: 'Selector uniquely identifies the element'
      });
      score += 40;
    } else {
      factors.push({
        factor: 'Non-unique selector',
        impact: 'negative',
        weight: 0.4,
        description: 'Selector matches multiple elements'
      });
      warnings.push('Selector matches multiple elements');
    }

    // Stability factor (40% weight)
    const stabilityContribution = (stabilityScore / 100) * 40;
    score += stabilityContribution;

    // Selector type factors (20% weight)
    if (selector.includes('#')) {
      factors.push({
        factor: 'ID selector',
        impact: 'positive',
        weight: 0.2,
        description: 'ID-based selectors are highly reliable'
      });
      score += 20;
    } else if (selector.includes('[')) {
      factors.push({
        factor: 'Attribute selector',
        impact: 'positive',
        weight: 0.15,
        description: 'Attribute-based selectors are moderately reliable'
      });
      score += 15;
    } else if (selector.includes('.')) {
      factors.push({
        factor: 'Class selector',
        impact: 'positive',
        weight: 0.1,
        description: 'Class-based selectors have moderate reliability'
      });
      score += 10;
    } else {
      // Tag-only selectors get negative points
      factors.push({
        factor: 'Tag-only selector',
        impact: 'negative',
        weight: 0.1,
        description: 'Tag-only selectors have low reliability'
      });
      score -= 10;
    }

    // Auto-generated class warning
    if (this.hasAutoGeneratedClasses(selector)) {
      warnings.push('Contains auto-generated class names that may change');
    }

    // Position-based selector warning
    if (selector.includes(':nth-child')) {
      warnings.push('Uses position-based selectors that may break with DOM changes');
    }

    return {
      score: Math.max(0, Math.min(100, Math.round(score))),
      factors,
      warnings
    };
  }

  /**
     * Tries to generate an ID-based selector
     */
  private tryIdSelector(element: HTMLElement): string | null {
    if (element.id && element.id.trim()) {
      return `#${element.id}`;
    }
    return null;
  }

  /**
     * Tries to generate an attribute-based selector
     */
  private tryAttributeSelector(element: HTMLElement): string | null {
    const tagName = element.tagName.toLowerCase();

    // For form elements, prefer name attribute
    if (['input', 'select', 'textarea'].includes(tagName)) {
      const name = element.getAttribute('name');
      if (name) {
        return `${tagName}[name="${name}"]`;
      }

      const type = element.getAttribute('type');
      if (type) {
        return `${tagName}[type="${type}"]`;
      }
    }

    return null;
  }

  /**
     * Tries to generate a class-based selector
     */
  private tryClassSelector(element: HTMLElement): string | null {
    if (element.className && element.className.trim()) {
      const classes = element.className.trim().split(/\s+/);
      const tagName = element.tagName.toLowerCase();
      const classSelector = classes.map(cls => `.${cls}`).join('');
      return `${tagName}${classSelector}`;
    }
    return null;
  }

  /**
     * Tries to generate a hierarchy-based selector
     */
  private tryHierarchySelector(element: HTMLElement): string | null {
    const parent = element.parentElement;
    if (!parent) {
      return element.tagName.toLowerCase();
    }

    // Build hierarchy selector
    const parentSelector = this.tryClassSelector(parent) || parent.tagName.toLowerCase();
    const childSelector = this.tryClassSelector(element) || element.tagName.toLowerCase();

    return `${parentSelector} > ${childSelector}`;
  }

  /**
     * Tries to generate a tag-based selector (fallback)
     */
  private tryTagSelector(element: HTMLElement): string {
    return element.tagName.toLowerCase();
  }

  /**
     * Checks if selector contains auto-generated class names
     */
  private hasAutoGeneratedClasses(selector: string): boolean {
    // Common patterns for auto-generated classes
    const autoGenPatterns = [
      /css-[a-z0-9]+/i,
      /[a-z]+-[0-9a-f]{6,}/i,
      /^[a-z]+[0-9]+$/i
    ];

    return autoGenPatterns.some(pattern => pattern.test(selector));
  }

  /**
     * Generates human-readable explanation for the selector
     */
  private generateExplanation(selector: string, isUnique: boolean, isStable: boolean): string {
    let explanation = `Generated CSS selector: ${selector}. `;

    if (selector.includes('#')) {
      explanation += 'Uses element ID for high reliability. ';
    } else if (selector.includes('[')) {
      explanation += 'Uses element attributes for moderate reliability. ';
    } else if (selector.includes('.')) {
      explanation += 'Uses CSS classes for identification. ';
    } else {
      explanation += 'Uses tag name as fallback selector. ';
    }

    if (!isUnique) {
      explanation += 'Warning: Selector may match multiple elements. ';
    }

    if (!isStable) {
      explanation += 'Warning: Selector may be unstable across page changes.';
    }

    return explanation.trim();
  }
}